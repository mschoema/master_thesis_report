\section{Terms and Concepts}



\begin{itemize}
	\item Moving object
	\item Moving region
	\item Fixed-shape moving region
	\item MOD
	\item MobilityDB
\end{itemize}

\section{Moving objects}

There exist a large variety of moving objects. These object can differ in two main ways. Either the type of their value differs, or they are using a different interpolation method.

	\subsection{Value types}

	In theory, for every non-temporal type, there could exist a moving object that extends this type with a temporal dimension. However, in this master thesis, we will only focus on the main types used in this field.

	\begin{itemize}
		\item Scalar types: boolean, string, integer, float
		\item Point types: Either 2d or 3d PostGIS Point types, or network-constrained points called npoints.
		\item Region types: Defined using the PostGIS Polygon type, these regions can either be deforming or fixed-shape.
	\end{itemize}

	\subsection{Interpolation}

	Since the values of a moving object are not stored at each time step, intermediate values have to be recomputed using a specific interpolation method. Moving objects with the same value type, but different interpolation methods will thus behave differently and can be considered as different objects. The two main interpolation methods used are:

	\begin{itemize}
		\item Stepwise interpolation (or piecewise constant interpolation): The value of the object does not change between two measurements, but jumps instantly at the time of the next measurement.
		\item Linear interpolation: The value of the object changes linearly between two saved values.
	\end{itemize}

	Discrete value types such as integer or boolean can only use the stepwise interpolation, but continuous types can use both. More complex interpolation methods, such as polynomial or spline interpolation could also be used, but this is not discussed in this work.

	\subsection{Examples}

	\begin{table}[h]
		\centering
		\begin{tabularx}{\textwidth}{
			| >{\raggedright\arraybackslash}X 
  			| >{\raggedright\arraybackslash}X 
  			| >{\raggedright\arraybackslash}X 
			|}
			\hline
			          				& \textbf{Stepwise} 							& \textbf{Linear} 		\\ \hline
			\textbf{Boolean} 		& State of a lightbulb in a room.				&  N/A 				\\ \hline
			\textbf{String} 		& Name of the world record holder for the 100m.	&  N/A       			\\ \hline
			\textbf{Integer} 		& Number of people in a bus.					&  N/A      			\\ \hline
			\textbf{Float} 		& World record time for the 100m.				&  Temperature in a room.		\\ \hline
			\textbf{Point}		& Position of the heighest building in the world	&   Position of players on a court	\\ \hline
			\textbf{NPoint} 		& Position of temporary radars on the side of the road	&   Position of a car       			\\ \hline
			\textbf{Fixed-shape Region} 	& ???	   									&   Movement of a floating city		\\ \hline
			\textbf{Deforming Region} 	& Cadastre         								&   Spread of a forest fire  			\\ \hline
		\end{tabularx}
	\end{table}

\section{Fixed-shape regions}

	In the previous section, the broad range of moving object has been presented. A lot can still be said about these different types of object, however, this thesis is mainly going to focus on diving deeper into the fixed-shape moving regions. These moving regions can generally be represented using simple polygons with zero or more holes. When we talk about a moving fixed-shape polygon, we talk about a certain polygon moving and rotating through time.
	
	\subsection{Representation}

	The first important question that can be asked about fixed-shape moving regions is: how can they be efficiently represented? In the following we will suppose that the polygon is defined at multiple moments in time and we assume that the position of the polygon at intermediate time steps can be found via some kind of interpolation. This is analogous to a moving point (ex: a car), where the position is measured and saved at multiple moments in time, and is supposed to be linearly interpolated. Seeing as the polygon is of fixed shape, storing the position of the polygon at each time step involves storing some redundancy and is thus not really efficient. The first idea is thus to to store the polygon only for the first time step, and then compute and store transformation vectors for the subsequent time steps. This idea has already been explored in \cite{fmregion} and their proposal is to store what they call a transformation unit. This transformation unit is defined between a start instant \( t_s \) and an end instant \( t_e \), and stores the following information.

	\begin{equation}
		T = (C, v_0, v, \theta_0, \theta, t_{s}, t_{e})
	\end{equation}

Where \( v \) is a translation vector and \( \theta \) is an angle. This representation assumes that both the start and the end transformation of the region is stored in the transformation. This is necessary if we suppose that the transformation center can change or if the subsequent transformations are not contiguous to each other. If however we suppose that the transformation center is always the same and that these transformations are contiguous, then there is a lot of redundant information in these transformation units. Since in the standards \note{Maybe more info about the standards?}, there is no mention of the rotation center, and the moving regions are all defined using polygons and not transformations, the rotation center can be chose arbitrarely. Our following supposition is thus that the rotation center of all moving regions is the centroid of the polygon representing the region. Below is a new proposition for the representation of a fixed-shape moving region:

	\begin{equation}
	\begin{split}
		& fmregion = (P_{ref}, [(T_0, t_0), (T_1, t_1), ..., (T_n, t_n)])
	\end{split}
	\end{equation}

	, where \( P_{ref} \) is a simple polygon with zero or more holes, and \( T_i \) is the transformation vector defining the position of the polygon at time \( t_i \). The instants \( t_i \) have to be sorted in increasing order for all \( i \). Since we suppose that the center of rotation is always the centro√Ød of the polygon defining the region, the information stored in a transformation vector only contains the translation an rotation fo the region. 

	\begin{equation}
	\begin{split}
		& T_{i} = \left ( t_x^{i}, t_y^{i}, \theta^{i} \right )
	\end{split}
	\end{equation}

	In most cases, the position of the polygon at time \( t_0 \) is used as reference polygon, and we have thus \( T_0 = (0, 0, 0) \).

	To compute these transformation vectors starting from two regions at two different time steps, multiple techniques are possible. \cite{fmregion} proposes a way to compute these transformation units that allow for some slight differences between the start and the end region. In the following however, we will suppose that the start and end regions are identical and that the corresponding points on each polygon are known. With this assumption made, it is sufficient to take the center of rotation and one other point of each polygon to compute the transformation. We define the start and end centroids, additional points and transformation vectors as follows:

	\begin{equation}
	\begin{split}
		& C^{i} = (c_{x}^{i}, c_{y}^{i}) \\
		& P^{i} = (p_{x}^{i}, p_{y}^{i}) \; \; \; \; \; i \in \left \{ start, end \right \} \\
		& T^{i} = \left ( t_x^{i}, t_y^{i}, \theta^{i} \right ) \\ 
	\end{split}
	\end{equation}

	Since every transformation is defined relative to a reference polygon, we also need to define this reference polygon. In this example case we will take the start region as being the reference polygon. This means that the start transformation vector will be zero: \( T_{start} = \left ( 0, 0, 0 \right ) \). The transformation vector for the end region can then be computed in the following way. First the translation component is computed by doing the difference between the positions of the start and end centroids.


	\begin{equation}
	\begin{split}
		& t_x^{end} = c_x^{end} - c_x^{start} \\
		& t_y^{end} = c_y^{end} - c_y^{start}
	\end{split}
	\end{equation}

	Then, the end polygon (only the needed point) is moved back to its starting position by cancelling the translation.


	\begin{equation}
	\begin{split}
		& {P^{end}}' = ({p_{x}^{i}}', {p_{y}^{i}}') \\
		& {p_x^{end}}' = p_x^{end} - t_x^{end} \\
		& {p_y^{end}}' = p_y^{end} - t_y^{end} \\
	\end{split}
	\end{equation}

	Finally, the angle between the start and end polygon is computed.

	\begin{equation}
	\begin{split}
		& \theta^{end} = \angle P^{start} C^{start} {P^{end}}' , \; \; \; \theta^{end} \in \left ] - \pi , \pi \right ]
	\end{split}
	\end{equation}

	\subsection{Operations on fixed-shape regions}

	Intro on operations

	List of operations with input to output types

	\begin{itemize}
		\item atinstant/getValue
		\item interpolate
		\item traversed area
		\item point inside
		\item distance?
		\item union or diff ?
	\end{itemize}

		\subsubsection{AtInstant/getValue}
		
		When defining a moving region over a certain time period, it is important to be able to know what the position of the region is at any instant in time during that time period. This is done using the \note{getValue / atInstant?} function. This function takes a moving region and an instant as input and returns the position of the region at that moment in time. To compute this position, we first have to compute the transformation of the region at that moment. When the transformation with respect to the reference region is know, we can just apply this transformation and we obtain the needed region. Applying this transformation to the reference region means applying it to every point of the region.
		With \( P = (p_x, p_y) \) being the start point and \( T = (t_x, t_y, \theta) \) being the transformation, we compute the end point \( P' = ({p_x}', {p_y}')  \) as follows:

		\begin{equation}
		\begin{split}
			& {p_x}' = cos(\theta)*p_x - sin(\theta)*p_y + t_x \\
			& {p_y}' = sin(\theta)*p_x + cos(\theta)*p_y + t_y \\
		\end{split}
		\end{equation}

		The main issue now is to compute the correct transformation for the given instant. Suppose that the position of the region is defined at time steps \( [t_0, t_1, t_2, ..., t_n] \) and that the region is well-defined between these time steps. 

		\begin{equation}
		\begin{split}
			& fmregion = (P_{ref}, [(T_0, t_0), (T_1, t_1), ..., (T_n, t_n)])
		\end{split}
		\end{equation}

		If the given instant is one of the \( t_i \)'s, then the corresponding transformation will be \( T_i \) and the work is done. If the instant is before \( t_0 \) or after \( t_n \), then the region will return an empty region \note{empty or error or null?}, since the region is not defined at that moment. Lastly if the instant is between \( t_i \) and \( t_{i+1} \), then the transformation has to be computed by interpolating between the transformations \( T_i \) and \( T_{i+1} \). This interpolation is explained in the following subsection.

		\subsubsection{Interpolation}

		Suppose that we know the position of a moving region at times \( t_i \) and \( t_{i+1} \) and that we want to know what the position of that region is in between these instants. Since we previously supposed that the respective points of different regions/polygons are known, a first possible interpolation method would be to linearly interpolate each respective vertex of the start and end polygon. An example of this can be seen below. \note{Add an example}

		As we see on above example, this seems to work well when the region is only translating. However, when the moving region is also rotating, this interpolation method fails to take the fixed-shape aspect of the region, and produces regions that are deforming along the translation. This comes from the fact that this interpolation method assumes that the vertices of the region move freely and independently of each other. For fixed-shape moving region this is unfortunately not the case, so this interpolation method cannot be used when rotations are involved. \note{Add an example}

		The solution for this is to interpolate the transformation instead of the vertices of the region. When applying a transformation (translation + rotation) to a region, the shape of the region will be maintained, which is what we want. To interpolate two transformations, two steps have to be done. First the translation vectors have to be linearly interpolated. Then the rotation has to be interpolated using a spherical interpolation method. For example: suppose that we want the transformation at time \( t_0 < t_i < t_1 \), with the transformations \( T_0 = (t_x^0, t_y^0, \theta^0) \) and \( T_1 = (t_x^1, t_y^1, \theta^1) \) at times \( t_0 \) and \( t_1 \) known. The transformation \( T_i = (t_x^i, t_y^i, \theta^i) \) can then be computed in the following way.

		\begin{equation}
		\begin{split}
			& r = \frac{t_1 - t_i}{t_1 - t_0} \\
			& t_x^i = t_x^0 * r + t_x^1 * (1-r) \\
			& t_y^i = t_y^0 * r + t_y^1 * (1-r) \\	
			& \theta^i = slerp(\theta^0, \theta^1, r) \\
		\end{split}
		\end{equation}

		To compute \( \theta^i \), we have to take into account the fact that we are interpolating an angle and that we want \( \theta^i \in \left ] - \pi , \pi \right ] \). Suppose without loss of generalization that \( \theta^0 <= \theta^1 \) (Otherwise just call \textit{slerp} with the parameters \( slerp(\theta^1, \theta^0, 1-r) \)). Two different cases have to be considered: the case where \( \theta^1 - \theta^0 <= \pi \) and the case where \( \theta^1 - \theta^0 > \pi \). Both cases are illustrated below.
		
		\note{graph with interpolation of angles}

		The \note{red?} portion of the circle corresponds to the values that the interpolated angle can take depending on the value of \( r \). In the first case, a linear interpolation of the angles gives the correct result. In the second case, however, we have to take into account the fact that  both angles are between \( -\pi \) and \( \pi \). The interpolated angle can then be computed by first adding \( 2\pi \) to the smallest angle, interpolating linearly the resulting angles and then substracting \( 2\pi \) from the resulting angle if it is larger than \( \pi \).

		\begin{equation}
		\begin{split}
			\text{case } 1: \, & \theta^i = \theta^0 * r + \theta^1 * (1-r) \\
			\text{case } 2: \, & \theta = (\theta^0 + 2\pi) * r + \theta^1 * (1-r) \\
						   	    & \theta^i = 
									\begin{cases}
										\theta - 2\pi, & \text{if } \theta^i > \pi\\
										\theta,         & \text{otherwise}
									\end{cases}
		\end{split}
		\end{equation}

		This method will give the correct interpolation for transformations in 2d. However, in 3d, Euler angles are hard to interpolate with the same method. There is thus another technique that allows for the interpolation of rotations in both 2d and 3d in a similar manner. This technique uses \textit{quaternions}, and is described in section \note{link to section}.

			
	\subsection{Quaternions for interpolation}
	
		\subsection{Representing 3d rotations using Quaternions}
			
		\subsubsection{Interpolating 2d and 3d rotations using Quaternions}
			
		\subsubsection{Interpolating 2d rotations using complex numbers}
			
			










